# mysql
* 客户端
* server层
* 存储引擎

## 索引
数据结构
* 树索引
* 哈希索引
物理存储角度
1. 聚集索引（clustered index）
2. 非聚集索引（non-clustered index）
逻辑角度
3. 普通索引
4. 唯一索引
5. 主键索引
6. 联合索引

## null值对索引的影响
where子句中使用上述对null的判断，如果判断的列设置了索引，那就可以使用到索引，但是类值为null时，
对索引查询的操作会比较复杂，应该尽量避免
为什么？？

## 索引失效场景
1. 索引计算
2. 对索引进行函数计算
3. 模糊查询以%开头
4. 字符串与数字比较 **在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。
5. 使用or时只有部分列有索引
总结：1.对索引目录进行改变，1,2   2.破坏开头3   3.



读提交在每个语句执行前重新生成Read View是什么意思？怎么理解？



锁的级别？？行级锁？表级锁？

- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，
- 因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 
- 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

怎么理解？？？？ 文档没有详细说





#### 行锁

Innodb支持行锁，MyISAM不支持

```sql
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```

行级锁的类型主要有三类：
- Record Lock，记录锁，也就是仅仅把一条记录锁上；
- Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
- Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
  **next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，
那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。
两种锁，所以包含两种锁的共性



为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行

数据是否加锁，使用意向锁来减少表锁的检查。?????



为什么select加的是X锁

## 如何进行MYSQL查询优化
1. 使用索引，避免索引失效
2. 禁止使用 select *
3. 分页优化
  ```sql
    没优化过的
    select `score`, `name` FROM `cus_oeder` ORDER BY `score` DESC LIMIT 1000000, 10;
    数据量大的时候就比较费时(为什么?)
    优化1:子查询
        select `score`, `name` FROM `cus_oeder` WHERE id >= (
            SELECT id FROM `cus_order` LIMIT 1000000, 1
          ) LIMIT 10;
    优化2:延迟查询
        SELECT `score`, `name` FROM `cus_oeder` a, 
  ```

## 简述Mysql中内连接和外连接的含义
内连接（inner join）：取出两张表中匹配到的数据，匹配不到的不保留
它会返回所有在两个表中都存在匹配的行。如果其中一个表中的行在另一个表中没有匹配的行，那么这个行不会出现在结果集中。
外连接（outer join）：取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL
会返回所有在两个表中存在匹配的行，以及在一个表中存在但在另一个表中没有匹配的行。对于没有找到匹配的行，结果集中的列将会是NULL。


## B+树的结构
结构：B+树索引是一种多路搜索树，它的每个节点可以拥有多个子节点。与二叉树不同，B+树的所有叶子节点都位于同一层，
这保证了查询时间的稳定性。

查找效率：由于B+树的高度相对较低，因此查找效率高。在数据库中，降低磁盘I/O操作次数是提高查询效率的关键，
B+树索引的设计正是为了这个目的。

排序和范围查找：B+树索引的叶子节点存储了全部的关键字信息，并且按照关键字排序，相邻的叶子节点通过指针相连，
这使得范围查找和排序变得更加高效。

数据存储：在B+树的非叶子节点中并不直接存储数据，而是存储其子节点的最大（或最小）关键字和指向子节点的指针。
数据记录实际存储在叶子节点中。

数据插入和删除：B+树的设计使得插入和删除操作相对容易，并且不会导致树的深度发生大的改变

数据库的设计范式
第一范式（1NF）：原子性（存储的数据应该具有“不可再分性”）
第二范式（2NF）：唯一性 (消除非主键部分依赖联合主键中的部分字段)（一定要在第一范式已经满足的情况下）
第三范式（3NF）：独立性，消除传递依赖(非主键值不依赖于另一个非主键值)
