# TCP/IP 网络模型有那几层？
## 应用层
应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。
应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，
由他负责运输快递，我们不需要关心快递是如何被运输的。
而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。
## 传输层
应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。
在传输层会有两个传输协议，分别是 TCP 和 UDP
* TCP --传输控制协议， 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，
  保证数据包能可靠地传输给对方。http基于TCP
* UDP 只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。

应用需要传输的数据可能会非常大，需要将数据分块，TCP协议每个分块叫TCP段
传输层报文口会携带端口号
## 网络层
我们不希望传输层协议处理太多的事情，只需要服务好应用即可，
让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层

网络层最常使用的是 **IP 协议（Internet Protocol）**，IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文
，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。

IP 地址分成两种意义：
一个是网络号，负责标识该 IP 地址是属于哪个「子网」的；
一个是主机号，负责标识同一「子网」下的不同主机；

IP地址配合子网掩码才能算出网络号和主机号

IP协议有寻址和导航的能力
路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。

IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。
寻址更像在导航，路由更像在操作方向盘

ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。
ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

## 网络接口层
生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，
并封装成数据帧（Data frame）发送到网络上。

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。

网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，
工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。

## 总结
网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），
HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。


## TCP协议是面向字节流的网络协议，这意味着数据以字节流的形式传递，没有“消息边界”的概念，请问应用层应该如何解决这个问题？
固定长度消息：如果所有的消息都是同样的长度，那么接收端可以每次读取固定大小的数据。
这是最简单的方法，但它对于不同长度的消息来说并不适用。
例如，在银行系统或其他金融系统中，经常使用定长的报文格式，因为这样可以简化处理逻辑，并且易于调试和排错

长度前缀：在每个消息前面加上该消息的长度，这样接收端可以先读取长度，然后再根据这个长度读取相应的数据。
这是一种很常见的方法，可以处理任意长度的消息。


分隔符：如果消息中包含的数据不会出现特定的字符或字符串，那么可以使用这些特定的字符或字符串作为消息的分隔符。
接收端可以一直读取数据直到读取到分隔符。这种方法的难点在于需要确保分隔符不会出现在消息数据中。
例如SMTP、HTTP等。在这类协议中，消息通常由多行文本组成，每行文本都以\r\n作为结束标志。

特殊的结束字符：类似于分隔符，但是这个特殊字符表示消息的结束而不是开始。例如，网络协议中常见的\r\n\r\n序列。
例如在FTP协议中，每个命令的结束都是由\r\n表示

使用更高层的协议：例如，HTTP、WebSocket等协议都在TCP之上提供了自己的消息边界定义

HTTP 1.0 / HTTP 1.1
在 HTTP 1.0 和 HTTP 1.1 中，消息的边界由请求或响应的头部信息定义。
具体来说，Content-Length头部字段定义了随后的消息体的长度，按字节计算。
例如，如果 Content-Length 的值为 1234，那么消息体的长度就应该是1234字节。

另一种定义消息边界的方式是使用 Transfer-Encoding 头部字段，其值设为 chunked。
这种方式下，消息体被分成多个块，每个块由长度值开始，然后是数据，最后是一个额外的回车符和换行符。
最后一个块的长度值为0，表示消息结束。

HTTP/2
在 HTTP/2 中，消息边界的处理更为复杂，使用了一个基于帧的模型。
HTTP/2 消息被封装在一个或多个帧中，每个帧都有一个头部，包含帧的类型、长度和其他属性。
例如，HEADERS 帧包含了一个HTTP请求或响应的头部信息，DATA 帧包含了请求或响应的消息体

## http的请求过程

