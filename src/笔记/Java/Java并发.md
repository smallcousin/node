## JMM详解
Java内存模型描述了Java程序中各种共享变量（线程间共享）的访问规则，以及在并发环境下，如何处
理各种复杂的情况。Java内存模型的主要目标是定义程序中的各种变量的访问方式，以及在单处理器或多处
理器环境中处理并发正常或非正常访问等问题。

## 死锁产生的条件
1. 互斥条件（Mutual Exclusion）：至少有一个资源必须处于非 共享模式，即一次只有一个进程可以使用。
如果其他进程请求该资源，那么请求进程必须等到占有资源的进程释放资源。
2. 占有并等待（Hold and Wait）：一个进程必须持有至少一个资源并等待获取其他进程已经占有的资源。
3. 不可抢占（No Preemption）：资源不能被强行从占有它的进程中抢占，只有当进程完成任务后才能释放资源。
4. 循环等待（Circular Wait）：存在一组等待进程，其中每个进程都在等待下一个进程所占有的资源，这形成了一个循环。

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

## 死锁产生的原因
（1） 因为系统资源不足。
（2） 进程运行推进的顺序不合适。
（3） 资源分配不当等。

资源竞争：当多个进程同时请求同一资源时，如果资源的分配策略不当，就可能会导致死锁。
例如，两个进程各自占有一部分资源，但同时需要对方占有的资源才能继续执行。

非预防性资源调度：在某些情况下，操作系统并未预先制定有效的资源调度策略，这可能导致资源的分配顺序导致死锁。
例如，系统允许进程在持有其他资源的同时请求新资源，这可能导致循环等待条件，从而产生死锁。

多个进程间的通信不当：如果进程间的通信没有得到良好的同步，也可能会产生死锁。
例如，两个进程互相发送请求，等待对方的响应，而又没有设置超时机制，就可能会导致死锁。

嵌套锁：在并发编程中，如果一个线程在持有一个锁的情况下试图获取另一个锁，而这个锁正被另一个线程持有，这可能导致死锁。
这种情况常发生在嵌套锁或复杂的锁定策略中。





