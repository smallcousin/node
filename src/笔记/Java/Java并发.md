## JMM详解
Java内存模型描述了Java程序中各种共享变量（线程间共享）的访问规则，以及在并发环境下，如何处
理各种复杂的情况。Java内存模型的主要目标是定义程序中的各种变量的访问方式，以及在单处理器或多处
理器环境中处理并发正常或非正常访问等问题。

## 死锁产生的条件
1. 互斥条件（Mutual Exclusion）：至少有一个资源必须处于非 共享模式，即一次只有一个进程可以使用。
如果其他进程请求该资源，那么请求进程必须等到占有资源的进程释放资源。
2. 占有并等待（Hold and Wait）：一个进程必须持有至少一个资源并等待获取其他进程已经占有的资源。
3. 不可抢占（No Preemption）：资源不能被强行从占有它的进程中抢占，只有当进程完成任务后才能释放资源。
4. 循环等待（Circular Wait）：存在一组等待进程，其中每个进程都在等待下一个进程所占有的资源，这形成了一个循环。

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

## 死锁产生的原因
（1） 因为系统资源不足。
（2） 进程运行推进的顺序不合适。
（3） 资源分配不当等。

资源竞争：当多个进程同时请求同一资源时，如果资源的分配策略不当，就可能会导致死锁。
例如，两个进程各自占有一部分资源，但同时需要对方占有的资源才能继续执行。

非预防性资源调度：在某些情况下，操作系统并未预先制定有效的资源调度策略，这可能导致资源的分配顺序导致死锁。
例如，系统允许进程在持有其他资源的同时请求新资源，这可能导致循环等待条件，从而产生死锁。

多个进程间的通信不当：如果进程间的通信没有得到良好的同步，也可能会产生死锁。
例如，两个进程互相发送请求，等待对方的响应，而又没有设置超时机制，就可能会导致死锁。

嵌套锁：在并发编程中，如果一个线程在持有一个锁的情况下试图获取另一个锁，而这个锁正被另一个线程持有，这可能导致死锁。
这种情况常发生在嵌套锁或复杂的锁定策略中。


## 同步和异步的区别
同步（Synchronous）和异步（Asynchronous）是指在执行操作或调用函数时，是否需要等待操作或函数完成后才继续执行后续任务的方式。

同步：在同步操作或调用函数时，后续任务会等待当前操作或函数执行完毕后才会继续执行。同步操作具有顺序性，因此易于理解和实现。
但是，同步操作可能导致整个流程阻塞，特别是在执行耗时任务时，会影响程序的性能和响应速度。

例如，当你在浏览器中访问一个网页时，浏览器需要依次下载所有的资源（如HTML、CSS、JavaScript等），这个过程是同步的，
因为浏览器需要等待一个资源下载完成后才能继续下载下一个资源。

异步：异步操作或调用函数时，不会阻塞后续任务的执行。异步操作在启动后，会立即返回（通常返回一个标识，如Promise、Callback等），
让程序继续执行后续任务。当异步操作完成时，会通过一定的机制（如回调函数、事件等）通知程序。异步操作可以提高程序的性能和响应速度，
特别是在执行耗时任务时。但是，由于异步操作具有非顺序性，因此可能会增加代码的复杂性。

例如，当你在浏览器中访问一个网页时，如果浏览器使用异步操作加载资源，那么它不需要等待一个资源下载完成后才能继续下载下一个资源，
而是可以同时下载多个资源，从而提高页面加载速度。同时，当某个资源下载完成时，浏览器可以立即开始处理该资源，
而不需要等待其他资源全部加载完毕。

## 如何预防死锁
从四个必要条件入手

## ReentrantLock的特点
可重入  公平锁  响应中断  限时等待
公平锁和限时等待不太理解

## ReadWriteLock 的简单使用
简单来讲，就是该接口允许一次读取多个线程，但一次只能写入一个线程

## 原子性  可见性
原子性：同时成功或同时失败  可见性：一个线程修改某个值，其他线程能马上看到

## 说一下CAS算法
CAS是一种无锁的并发控制算法，它包含三个参数CAS(V, A, B)。V代表要更新的变量，A代表预期值，B代表新值。
当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作。一般情况下，“更新的值”是通过某种算法计算得到的，
而不是固定的。如果用单线程执行CAS操作，那就不存在什么问题，但实际情况常常是在并发情况下使用CAS，此时可能会出现一个线程获取了变
的旧值，然后通过算法得到新值，而这个过程中，其他线程已经修改了这个变量，那么当前线程再用CAS进行更新时就会失败。

## CAS自旋？？？





