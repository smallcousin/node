## java的GC
1. 串行垃圾回收器(Serial Collector)：这种回收器适合运行在单核心或者小资源的机器上。
它在进行垃圾回收时，会暂停所有的用户线程，直到它回收完所有的空间（这种现象叫做Stop-the-world）。
2. 并行垃圾回收器(Parallel Collector)：又叫吞吐量收集器，它的目标是获取最高的吞吐量。
它在垃圾收集时也会Stop-the-world，但是其回收垃圾的过程是多线程的，所以总体速度会快一些。
3. 并发标记扫描垃圾回收器(CMS Collector)：CMS回收器的目标是获取最小的回收停顿时间。
它几乎不会Stop-the-world，大部分工作都是和应用线程一起并发执行的。
4. G1垃圾回收器(G1 Collector)：G1是目前比较新的一种，它将堆内存划分为多个小块，可以并行、并发的进行垃圾回收，
旨在替代CMS收集器，实现高吞吐和可预测停顿时间的同时。

## Java的垃圾收集算法
标记-清除（Mark-Sweep）：这个算法分为“标记”和“清除”两个阶段。首先标记出所有需要回收的对象，在标记完成后统一进行回收。

复制（Copying）：这个算法把内存分为两块，每次只使用其中一块。当这一块内存用完，就将正在使用的对象复制到另外一块上面，
然后再把已使用过的内存空间一次清理掉。

标记-整理（Mark-Compact）：这个算法是标记-清除算法的改进版，标记过程仍然与标记-清除算法一样，
但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

分代收集（Generational Collection）：这个算法把Java堆分为新生代和老年代，这样就可以根据各个年代的特点选择合适的收集算法。
比如新生代频繁产生垃圾，就选择复制算法，老年代对象存活率高、没有额外空间对它进行分配担保，就选择标记-清理或者标记-整理算法。

## Java对小内存对象的分配
对象池（Object Pooling）: 对于小而频繁使用的对象，Java可以使用对象池技术。这意味着当一个对象不再被使用时，
它不会被垃圾回收，而是返回到池中以供后续重用。这样可以减少对象的创建和销毁开销。

线程本地分配缓冲（Thread-Local Allocation Buffers，TLAB）: 在HotSpot虚拟机中，为了减少多个线程同时对内存申请的竞争，
每个线程在Java堆中预先分配一块内存作为私有区域。这样，线程在分配小对象时可以直接在自己的TLAB上进行，避免了线程间的竞争。

逃逸分析（Escape Analysis）: 这是Java HotSpot虚拟机中的一种优化技术。通过逃逸分析，虚拟机可以判断出对象的作用范围，
如果对象只在某个线程内部使用（即没有“逃逸”出去），那么可能会直接分配在栈上，而不是在堆上。这样可以避免在堆上分配和回收对象的开销。

新生代存储: 在Java的内存管理中，新创建的小对象通常被分配在新生代。新生代是使用高效的Minor GC进行管理的，
可以快速回收生命周期短的小对象。

## Java垃圾回收
1. 判断是不是垃圾
引用计数法 （会有循环依赖问题）   可达性算法（从GC root开始查找）（JVM采用的方法）
2. 如何回收垃圾
标记清除  复制算法  标记压缩  分代收集算法
3. 垃圾回收思想
分代思想  分区思想
因为2的算法都不怎么好  所以Java虚拟机采用了分代的垃圾回收思想
存活对象少的新生代区域，采用垃圾复制算法    老年代采用标记压缩和标记清除算法
对象98%是朝生夕死


## 可作为GC root的对象
1.虚拟机栈中引用的对象
2.本地方法栈引用的对象
2.方法区中静态属性引用的对象
3.方法区中常量引用的对象

**(1)** **年轻代（Young Generation）**

1.所有新生成的对象首先都是放在年轻代的。

2.新生代内存按照8:1:1的比例分为一个eden区和两个Survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。
回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，
则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，
然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。

3.当survivor1区不足以存放eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，
也就是新生代、老年代都进行回收。

4.新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)

**(2)** **年老代（Old Generation）**

1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

2.内存比新生代也大很多(大概是2倍)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，
老年代对象存活时间比较长，存活率比较高。

**(3)** **持久代（Permanent Generation）**

用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，从JDK8以后已经废弃, 将存放静态文件，如Java类、
方法等这些存储到了元数据区.