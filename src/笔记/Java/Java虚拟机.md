## java的GC
1. 串行垃圾回收器(Serial Collector)：这种回收器适合运行在单核心或者小资源的机器上。
它在进行垃圾回收时，会暂停所有的用户线程，直到它回收完所有的空间（这种现象叫做Stop-the-world）。
2. 并行垃圾回收器(Parallel Collector)：又叫吞吐量收集器，它的目标是获取最高的吞吐量。
它在垃圾收集时也会Stop-the-world，但是其回收垃圾的过程是多线程的，所以总体速度会快一些。
3. 并发标记扫描垃圾回收器(CMS Collector)：CMS回收器的目标是获取最小的回收停顿时间。
它几乎不会Stop-the-world，大部分工作都是和应用线程一起并发执行的。
4. G1垃圾回收器(G1 Collector)：G1是目前比较新的一种，它将堆内存划分为多个小块，可以并行、并发的进行垃圾回收，
旨在替代CMS收集器，实现高吞吐和可预测停顿时间的同时。

## Java的垃圾收集算法
标记-清除（Mark-Sweep）：这个算法分为“标记”和“清除”两个阶段。首先标记出所有需要回收的对象，在标记完成后统一进行回收。

复制（Copying）：这个算法把内存分为两块，每次只使用其中一块。当这一块内存用完，就将正在使用的对象复制到另外一块上面，
然后再把已使用过的内存空间一次清理掉。

标记-整理（Mark-Compact）：这个算法是标记-清除算法的改进版，标记过程仍然与标记-清除算法一样，
但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

分代收集（Generational Collection）：这个算法把Java堆分为新生代和老年代，这样就可以根据各个年代的特点选择合适的收集算法。
比如新生代频繁产生垃圾，就选择复制算法，老年代对象存活率高、没有额外空间对它进行分配担保，就选择标记-清理或者标记-整理算法。

## Java对小内存对象的分配
对象池（Object Pooling）: 对于小而频繁使用的对象，Java可以使用对象池技术。这意味着当一个对象不再被使用时，
它不会被垃圾回收，而是返回到池中以供后续重用。这样可以减少对象的创建和销毁开销。

线程本地分配缓冲（Thread-Local Allocation Buffers，TLAB）: 在HotSpot虚拟机中，为了减少多个线程同时对内存申请的竞争，
每个线程在Java堆中预先分配一块内存作为私有区域。这样，线程在分配小对象时可以直接在自己的TLAB上进行，避免了线程间的竞争。

逃逸分析（Escape Analysis）: 这是Java HotSpot虚拟机中的一种优化技术。通过逃逸分析，虚拟机可以判断出对象的作用范围，
如果对象只在某个线程内部使用（即没有“逃逸”出去），那么可能会直接分配在栈上，而不是在堆上。这样可以避免在堆上分配和回收对象的开销。

新生代存储: 在Java的内存管理中，新创建的小对象通常被分配在新生代。新生代是使用高效的Minor GC进行管理的，
可以快速回收生命周期短的小对象。

